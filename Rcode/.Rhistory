length(z)
plot(grid,col = ifelse(z < 10, 'blue', 'red'), pch = 19)
plot(grid, pch = 19)
plot(grid, pch = 1)
points(grid[z == 10], col = 'blue', pch = 19)
points(grid[z == 10,], col = 'blue', pch = 19)
sum(z==10)
points(grid[z < 10 && z > 9.5,], col = 'blue', pch = 19)
summary(z)
sum(z < 10)
sum(z < 10 && z > 9)
sum(z < 10 && z > 5)
sum(z < 10 && z > 1)
grid = make.grid(matrix(c(1,1000, 1,1000), nrow = 2), 100)
z <- as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len))
plot(grid, pch = 1)
points(grid[z < 10 && z > 9.5,], col = 'blue', pch = 19)
summary(z)
b_len = 26
seq_error = 0.01
b_d = 1
z <- as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len))
plot(grid, pch = 1)
points(grid[z < 10 && z > 9.5,], col = 'blue', pch = 19)
summary(z)
sum(z< 10 && z > 9.5)
sum(z< 10)
points(grid[z < 10], col = 'blue', pch = 19)
points(grid[z < 10,], col = 'blue', pch = 19)
grid = make.grid(matrix(c(1,10000, 1,10000), nrow = 2), 100)
z <- as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len))
plot(grid, pch = 1)
points(grid[z < 10,], col = 'blue', pch = 19)
? with
# check the distribution of z-value given fixed
# sequence error and
ZValue <- function(n1, n2, e1, e2) {
numerator = abs(e1 - e2)
denominator = sqrt(e1 * (1-e1)/n1 + e2 * (1 - e2)/n2)
numerator / denominator
}
testStatistics <- function(size, error, d, l) {
n1 = size[1] * l
n2 = size[2] * l
e1 = error
e2 = d / l
ZValue(n1, n2, e1, e2)
}
binomialStatistics <- function(size, error, d, l) {
prob = error**d * (1-error)**(l - d)
exp_count = size[1] *  prob
numerator = size[2] - exp_count
denominator = sqrt(size[1] * prob * (1-prob))
numerator/denominator
}
b_len = 26
seq_error = 0.01
b_d = 1
testStatistics(100, 100, seq_error, d, b_len)
testStatistics(c(100000, 100), seq_error, d, b_len)
x = seq(1, 100000, by = 100)
y = seq(1, 100000, by = 100)
grid = expand.grid(x,y)
z = as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len))
sim_data = as.data.frame(cbind(grid, z))
names(sim_data) = c("x", "y", "z.value")
require(lattice)
wireframe(z.value ~ x * y,
data = sim_data,
xlab = "X Coordinate", ylab = "Y Coordinate",
main = "Surface elevation data",
drape = TRUE,
colorkey = TRUE,
screen = list(z = -90, x = -90)
)
require(rgl)
plot3d(grid[,1],grid[,2],z, xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 10, 'red', 'blue'), size=3)
adjuestZvalue <- function(size, error, d, l) {
n1 = size[1] * l
n2 = size[2] * l
e1 = error
e2 = d / l
ZValue(n1, n2, e1, e2) * size[2]/size[1]
}
x = seq(1, 100000, by = 100)
y = seq(1, 1000, by = 1)
grid = expand.grid(x,y)
z = as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len))
adjust_z = as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = b_d, l = b_len))
plot3d(grid[,1],grid[,2],z, xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 10, 'red', 'blue'), size=3)
plot3d(grid[,1],grid[,2],z, xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'red', 'blue'), size=3)
plot3d(grid[,1],grid[,2],adjust_z, xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 10, 'red', 'blue'), size=3)
y = seq(1, 1000, by = 1)
x = seq(1, 100000, by = 100)
x = x + y
grid = expand.grid(x,y)
z = as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len))
adjust_z = as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = b_d, l = b_len))
plot3d(grid[,1],grid[,2],z, xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'red', 'blue'), size=3)
summary(x)
summary(y)
head(grid)
sum(grid[,1] > grid[,2])
plot3d(grid[,1],grid[,2],adjust_z, xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 10, 'red', 'blue'), size=3)
testStatistics <- function(size, error, d, l) {
if (size[1] < size[2]) {
size = rev(size)
}
n1 = size[1] * l
n2 = size[2] * l
e1 = error
e2 = d / l
return(c(ZValue(n1, n2, e1, e2), size))
}
adjuestZvalue <- function(size, error, d, l) {
n1 = size[1] * l
n2 = size[2] * l
e1 = error
e2 = d / l
result = ZValue(n1, n2, e1, e2)
return(c(result[1] * result[3]/result[2], result[2], result[3]))
}
testStatistics <- function(size, error, d, l) {
if (size[1] < size[2]) {
size = rev(size)
}
n1 = size[1] * l
n2 = size[2] * l
e1 = error
e2 = d / l
return(c(ZValue(n1, n2, e1, e2), size))
}
adjuestZvalue <- function(size, error, d, l) {
n1 = size[1] * l
n2 = size[2] * l
e1 = error
e2 = d / l
result = ZValue(n1, n2, e1, e2)
return(c(result[1] * result[3]/result[2], result[2], result[3]))
}
b_len = 26
seq_error = 0.01
b_d = 1
x = seq(1, 100000, by = 100)
y = seq(1, 1000, by = 1)
grid = expand.grid(x,y)
z = as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len))
length(z)
z[1]
z[2]
z[[1]]
z[[1],]
summary(z)
is.list(z)
z[1:3]
z = as.matrix(z, nrow = 3)
z[,1]
z[1,]
z = as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len))
z[1:3]
? as.matrix
m = as.matrix(z, nrow = 3)
dim(m)
m = matrix(data = z, nrow = 3)
dim(m)
m[,1]
m[,2]
z = t(matrix(as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len)),,nrow = 3))
z[1,]
z[2,]
adjust_z = t(matrix(as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = b_d, l = b_len)),,nrow = 3))
plot3d(z[,2],z[,3],z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'red', 'blue'), size=3)
plot3d(adjust_z[,2],adjust_z[,3],adjust_z, xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 10, 'red', 'blue'), size=3)
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 10, 'red', 'blue'), size=3)
adjust_z[1,]
adjuestZvalue <- function(size, error, d, l) {
result = testStatistics(size, error, d,l)
return(c(result[1] * result[3]/result[2], result[2], result[3]))
}
adjust_z = t(matrix(as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 10, 'red', 'blue'), size=3)
adjust[1,]
adjust_z[1,]
adjust_z[2,]
adjust_z[3,]
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'red', 'blue'), size=3)
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'red', 'blue'), size=3)
sum(adjust_z[,2] > adjust[,3])
sum(adjust_z[,2] > adjust_z[,3])
sum(adjust_z[,2] >= adjust_z[,3])
adjust_z = t(matrix(as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'red', 'blue'), size=3)
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'red', 'blue'))
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'white', 'blue'))
tail(adjust_z)
plot3d(z[,2],z[,3],z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'pink', 'blue'), size=3)
adjuestZvalue <- function(size, error, d, l) {
result = testStatistics(size, error, d,l)
return(c(result[1] * result[3]/result[2], result[2], result[3]))
}
adjust_z = t(matrix(as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z > 5, 'pink', 'blue'))
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(adjust_z[,1] > 5, 'pink', 'blue'))
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(adjust_z[,1] > 1.96, 'pink', 'blue'))
adjuestZvalue <- function(size, error, d, l, z0 = 1.96) {
result = testStatistics(size, error, d,l)
return(c(result[1] * result[3]/result[2] + z0, result[2], result[3]))
}
b_len = 26
seq_error = 0.01
b_d = 1
adjust_z = t(matrix(as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
adjust_z_2 = t(matrix(as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = 2, l = b_len)),nrow = 3))
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(adjust_z[,1] > 5, 'pink', 'blue'))
plot3d(adjust_z_2[,2],adjust_z_2[,3],adjust_z_2[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(adjust_z_2[,1] > 5, 'pink', 'blue'))
logit < function(p) {
return(log(p/(1-p)))
}
logit < function(p) {
return(log(p/(1-p)))
}
logit <- function(p) {
return(log(p/(1-p)))
}
logit(0)
logit(0.5)
logit(1)
logit <- function(p) {
return(1/(1 + exp(p)))
}
logit(0)
logit(1)
logit(10)
logit(-10)
logitZvalue <- function(size, error, d, l, z0 = 1.96) {
result = testStatistics(size, error, d,l)
return(c(z0 + result[1] * logit(abs(result[3]/result[2] - error)), result[2], result[3]))
}
logit(0.01)
logit(-0.01)
logitZvalue <- function(size, error, d, l, z0 = 1.96) {
result = testStatistics(size, error, d,l)
return(c(z0 + result[1] * logit(result[3]/result[2] - error), result[2], result[3]))
}
logit_z = t(matrix(as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(logit_z[,2],logit_z[,3],logit_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(logit_z[,1] > 5, 'pink', 'blue'))
plot3d(logit_z[,2],logit_z[,3],logit_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(logit_z[,1] > 2.56, 'pink', 'blue'))
logit(1)
plot(logit_z[,2]/logit_z[,3], logit_z[,1])
plot(logit_z[,2]/logit_z[,3], logit_z[,1], type ='b')
plot3d(z[,2],z[,3],z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z[,1] > 5, 'pink', 'blue'), size=3)
x = seq(1, 100000, by = 100)
y = seq(1, 100000, by = 100)
grid = expand.grid(x,y)
z = t(matrix(as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(z[,2],z[,3],z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(z[,1] > 5, 'pink', 'blue'), size=3)
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(adjust_z[,1] > 5, 'pink', 'blue'))
x = seq(1, 100000, by = 100)
y = seq(1, 100000, by = 100)
z = t(matrix(as.numeric(apply(grid, 1, testStatistics,error = seq_error, d = b_d, l = b_len)),nrow = 3))
adjust_z = t(matrix(as.numeric(apply(grid, 1, adjuestZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(adjust_z[,2],adjust_z[,3],adjust_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(adjust_z[,1] > 5, 'pink', 'blue'))
testStatistics <- function(size, error, d, l) {
if (size[1] < size[2]) {
size = rev(size)
}
n1 = size[1] * l
n2 = size[2] * l
e1 = error
e2 = d / l
return(c(ZValue(n1, n2, e1, e2), size))
}
testStatistics(c(100000, 1e3), 0.01, 1, 26)
testStatistics(c(100000, 1e3), 0.01, 2, 26)
testStatistics(c(100000, 1e3), 0.01, 3, 26)
testStatistics(c(3000000, 6e3), 0.01, 3, 26)
testStatistics(c(3e6, 6e3), 0.01, 3, 26)
testStatistics(c(3e6, 6e3), 0.01, 2, 26)
testStatistics(c(3e6, 6e3), 0.01, 1, 26)
b_len = 26
seq_error = 0.003
b_d = 1
#testStatistics(100, 100, seq_error, d, b_len)
#testStatistics(c(100000, 100), seq_error, d, b_len)
x = seq(1,   10000000, by = 100)
y = seq(0.5, 5000, by = 5)
length(x)
length(y)
x = seq(1,   10000000, by = 1000)
y = seq(0.5, 5000, by = 5)
length(x)
length(y)
x = seq(1,   1000000, by = 1000)
y = seq(0.5, 5000, by = 5)
length(x)
length(y)
grid = expand.grid(x,y)
logit_z = t(matrix(as.numeric(apply(grid, 1, logitZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(logit_z[,2],logit_z[,3],logit_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(logit_z[,1] > 4, 'pink', 'blue'))
require(rgl)
plot3d(logit_z[,2],logit_z[,3],logit_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(logit_z[,1] > 4, 'pink', 'blue'))
logitZvalue(c(10000,10), 0.003, 1,26)
logitZvalue(c(10000,100), 0.003, 1,26)
testStatistics(c(10000,10), 0.003, 1,26)
logitZvalue <- function(size, error, d, l, z0 = 1.96) {
result = testStatistics(size, error, d,l)
prob = error**d * (1-error)**(l - d)
#return(c(z0 + result[1] * logit(-result[3]/result[2]/error), result[2], result[3]))
print(logit(result[3]/result[2] - prob))
return (c(result[1] * logit(result[3]/result[2] - prob), result[2], result[3]))
}
logitZvalue(c(10000,100), 0.003, 1,26)
testStatistics(c(10000,10), 0.003, 1,26)
logitZvalue <- function(size, error, d, l, z0 = 1.96) {
result = testStatistics(size, error, d,l)
prob = error**d * (1-error)**(l - d)
#return(c(z0 + result[1] * logit(-result[3]/result[2]/error), result[2], result[3]))
print(result[1],logit(result[3]/result[2] - prob))
return (c(result[1] * logit(result[3]/result[2] - prob), result[2], result[3]))
}
testStatistics(c(10000,10), 0.003, 1,26)
logitZvalue(c(10000,100), 0.003, 1,26)
testStatistics <- function(size, error, d, l) {
if (size[1] < size[2]) {
size = rev(size)
}
n1 = size[1] * l
n2 = size[2] * l
e1 = error
e2 = d / l
return(c(ZValue(n1, n2, e1, e2), size))
}
logitZvalue(c(10000,100), 0.003, 1,26)
testStatistics(c(10000,10), 0.003, 1,26)
logitZvalue <- function(size, error, d, l, z0 = 1.96) {
result = testStatistics(size, error, d,l)
prob = error**d * (1-error)**(l - d)
#return(c(z0 + result[1] * logit(-result[3]/result[2]/error), result[2], result[3]))
print(result,logit(result[3]/result[2] - prob))
return (c(result[1] * logit(result[3]/result[2] - prob), result[2], result[3]))
}
logitZvalue(c(10000,100), 0.003, 1,26)
logitZvalue <- function(size, error, d, l, z0 = 1.96) {
result = testStatistics(size, error, d,l)
prob = error**d * (1-error)**(l - d)
#return(c(z0 + result[1] * logit(-result[3]/result[2]/error), result[2], result[3]))
print(result)
print(logit(result[3]/result[2] - prob))
return (c(result[1] * logit(result[3]/result[2] - prob), result[2], result[3]))
}
logitZvalue(c(10000,100), 0.003, 1,26)
testStatistics(c(10000,100), 0.003, 1,26)
logitZvalue <- function(size, error, d, l, z0 = 1.96) {
result = testStatistics(size, error, d,l)
prob = error**d * (1-error)**(l - d)
#return(c(z0 + result[1] * logit(-result[3]/result[2]/error), result[2], result[3]))
return (c(result[1] * logit(result[3]/result[2] - prob), result[2], result[3]))
}
x = seq(1,   1000000, by = 1000)
y = seq(0.5, 5000, by = 5)
grid = expand.grid(x,y)
logit_z = t(matrix(as.numeric(apply(grid, 1, logitZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(logit_z[,2],logit_z[,3],logit_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(logit_z[,1] > 4, 'pink', 'blue'))
logit <- function(p) {
return(exp(10*p)/(1 + exp(10*p)))
}
logitZvalue <- function(size, error, d, l, z0 = 1.96) {
result = testStatistics(size, error, d,l)
prob = error**d * (1-error)**(l - d)
#return(c(z0 + result[1] * logit(-result[3]/result[2]/error), result[2], result[3]))
return (c(result[1] * logit(result[3]/result[2] - prob), result[2], result[3]))
}
logit_z = t(matrix(as.numeric(apply(grid, 1, logitZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
logit <- function(p) {
return(exp(200*p)/(1 + exp(200*p)))
}
logit_z = t(matrix(as.numeric(apply(grid, 1, logitZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(logit_z[,2],logit_z[,3],logit_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(logit_z[,1] > 4, 'pink', 'blue'))
logit <- function(p) {
return(exp(2000*p)/(1 + exp(2000*p)))
}
logit_z = t(matrix(as.numeric(apply(grid, 1, logitZvalue,error = seq_error, d = b_d, l = b_len)),nrow = 3))
plot3d(logit_z[,2],logit_z[,3],logit_z[,1], xlab = "s1", ylab = "s2", zlab = "zvalue",col = ifelse(logit_z[,1] > 4, 'pink', 'blue'))
dev.off()
# Plot the estimated error rate along the time.
timepoint = c(1,20, 50, 60, 65,70,seq(73,81), 83, 85,87,89, 91, 93,97,105, 113)
error_rate = c(0.019401,0.0193418,0.0192438,0.0194944,0.0196037,0.0196595,
0.0197155,0.0196882,0.0196974,0.0196849,0.019683,0.0196874,
0.0197069,0.0196915,0.0196668,0.0197005,0.0197186,0.0197108,
0.0197126,0.0197106,0.0196915,0.0196947,0.0196945,0.0197154)
plot(timepoint, error_rate, xlab = 'Time point', ylab = 'Estimated Error rate',
main = 'Estimated errror rate', type = 'b', pch = 19,cex = 0.2,
ylim = c(min(error_rate) - 0.0001, max(error_rate)))
plot(timepoint, error_rate, xlab = 'Time point', ylab = 'Estimated Error rate',
main = 'Estimated errror rate', type = 'b', pch = 19,cex = 0.2,
ylim = c(0,.02))
plot(timepoint, error_rate, xlab = 'Time point', ylab = 'Estimated Error rate',
main = 'Estimated errror rate', type = 'b', pch = 19,cex = 0.5,
ylim = c(0,.02))
plot(timepoint, error_rate, xlab = 'Time point', ylab = 'Estimated Error rate',
main = 'Estimated errror rate', type = 'o', pch = 19,cex = 0.5,
ylim = c(0,.02))
abline(h = 0.1999)
abline(h = 0.1999,lty = 2)
plot(timepoint, error_rate, xlab = 'Time point', ylab = 'Estimated Error rate',
main = 'Estimated errror rate', type = 'o', pch = 19,cex = 0.5,
ylim = c(0,.02))
abline(h = 0.1999,lty = 2, add = T,col = 'gray')
plot(timepoint, error_rate, xlab = 'Time point', ylab = 'Estimated Error rate',
main = 'Estimated errror rate', type = 'o', pch = 19,cex = 0.5,
ylim = c(0,.02))
abline(h = 0.1999,lty = 2, col = 'gray')
plot(timepoint, error_rate, xlab = 'Time point', ylab = 'Estimated Error rate',
main = 'Estimated errror rate', type = 'o', pch = 19,cex = 0.5,
ylim = c(0,.02))
abline(h = 0.1999,lty = 2, col = 'gray')
plot(timepoint, error_rate, xlab = 'Time point', ylab = 'Estimated Error rate',
main = 'Estimated errror rate', type = 'o', pch = 19,cex = 0.5,
ylim = c(0,.02))
abline(h = 0.01999,lty = 2, col = 'gray')
testStatistics(c(34,4), 0.01, 1,26)
testStatistics(c(1385,28), 0.01, 1,26)
0.003*(.997^25)
0.98 ^ 20
# single time plot
library(ggplot2)
library(reshape2)
library(plyr)
# plot the Venndiagram
setwd("~/Documents/barcode_single_end/Rcode")
library(VennDiagram)
#source("/Users/lukez/Documents/barcode_single_end/Rcode/distance_bitwise_util.R")
truth = read.table("../simulation_data/True_barcode_seq.csv",
header = F, sep = ',', stringsAsFactors = F)
#
# cluster <- read.table("../simulation_data/simulated_data_cluster_cluster.csv",
#                       header = TRUE, sep = ',', stringsAsFactors = F)
cluster <- read.table("../simulation_data/primer_test_seed_5_cluster.csv",
header = TRUE, sep = ',', stringsAsFactors = F)
# filter out low frequency barcode
valid_truth = truth[which(truth$V2 > 2),]
valid_estimate = cluster[which(cluster$time_point_1 > 2),]
#plot distribution
dev.off()
# Histogram Grey Color
hist(valid_truth$V2, col=rgb(1,0,0,0.5),
xlim=c(3, 1200), ylim=c(0,40000),
main="Overlapping Histogram")
hist(valid_estimate$time_point_1,
col=rgb(0,1,1,0.2),
add=T)
box()
plot(density(valid_truth$V2), col = rgb(1,0,0, alpha = 0.3),
lwd = 5, lty = 1,
main = "Frequency distributions of truth and estimated",
xlab = "Barcode frequency")
lines(density(valid_estimate$time_point_1), col = rgb(0,0,1,alpha = 1), lty = 2, lwd = 2)
legend("topright", legend = c("Truth", "Estimated"),
col =c(rgb(1,0,0, alpha = 0.3), rgb(0,0,1,alpha = 1)),
lty = c(1,2),
lwd = c(5,2))
merged = merge(valid_truth, valid_estimate, by.x = "V1", by.y = "Center")
missing = valid_truth[!(valid_truth$V1 %in% merged$V1),c("V2")]
false_positive = valid_estimate[!(valid_estimate$Center %in% merged$V1), c("time_point_1")]
cor(merged$V2, merged$time_point_1)
cor(merged$V2, merged$time_point_1) ^ 2
dev.off()
# plot for the single time point
# Add boxplots to a scatterplot
plot.new()
box()
library(LSD)
par(fig = c(0.01,0.8,0.01,0.8), new = T)
break.x = c(0,seq(100, max(merged$V2), by = 100),1200)
break.y = c(0, seq(100, max(merged$time_point_1), by = 100),1200)
plot(merged$V2, merged$time_point_1,
main = "", pch = 19, ylab = '', xlab = '',
col = 'blue',cex = 0.5, axes = F)
axis(3, at = break.x, col.lab = 'red', pos = 1200,  tck = -0.008)
axis(4, at = break.y, col.lab = "blue",tck = -0.008, pos = 1200)
lines(c(0,1200), c(0, 1200))
text(800, 500, labels = bquote(R^2 == .(cor(merged$V2, merged$time_point_1) ^ 2), col = "blue")
)
text(800, 500, labels = bquote(R^2 == .(cor(merged$V2, merged$time_point_1) ^ 2)), col = "blue")
text(600,1170, labels = "Truth")
text(1180, 600, labels = "Estimated", srt = -90)
par(fig=c(0.08,0.765,0.75,0.85), new=TRUE)
par(mar = c(0.5,0.5,1,0.5),mgp = c(3,1,0))
palette<- colorRampPalette(c("grey90", "dark green"))
mypalette<-palette(50)
break.x = seq(min(merged$V2), max(merged$V2), by = 5)
break.y = seq(min(merged$time_point_1), max(merged$time_point_1), by = 5)
z.fp = matrix(0, nrow = max(merged$V2), ncol = 1)
for (f in missing) {
z.fp[f] = z.fp[f] + 1
}
image( z.fp, 1,
col=mypalette,
xlab="",ylab="",axes = F)
mtext("False negative barcodes", line = 0.5, cex = 0.8, side = 3)
#library(grid)
par(fig=c(0.81,0.85,0.137,0.71),new=TRUE)
par(mar = c(0.5,0.5,0.5,0.1))
#xhist.count[c(which.min(xhist.count!=0),which.max(xhist.count!=0))]=0;
z.fp = matrix(0, nrow = max(merged$time_point_1), ncol = max(merged$time_point_1))
for (f in false_positive) {
z.fp[,f] = z.fp[,f] + 1
}
image(1:max(merged$time_point_1),1:max(merged$time_point_1),z.fp,
col=mypalette,
xlab="",ylab="",axes = F)
mtext("False positive barcodes",side=4,cex=0.8,line = 0.1, padj = 0) #Plot your title
